<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Infrared Remote Control Experiment</title>

  <!-- Prism.js syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>

  <!-- Includes the stylesheet file styles.css -->
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <!-- Fixed Navigation Menu -->
  <nav id="menu">
    <h3>Menu</h3>
    <ul>
      <li><a href="#top">Title</a></li>
      <li><a href="#information">Project Information</a></li>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#circuit-diagram">Circuit</a></li>
      <li><a href="#environment">Environment</a></li>
      <li><a href="#bom">BoM</a></li>
      <li><a href="#prototype">Prototype</a></li>
      <li><a href="#code">Code</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      <li><a href="#references">References</a></li>
    </ul>
  </nav>


  <h1 id="top">Infrared Remote Control Experiment</h1>

  <section id="information">
    <h2>Project Information</h2>
    <p><strong>Course:</strong> TECH 117 (Computer Engineering Technology, Fall 2025)</p>
    <p><strong>Instructor:</strong> Ph.D. Ana Rodrigues</p>
    <p><strong>Team Members:</strong></p>
    <ul>
      <li>Matteo Vuceta</li>
      <li>Kaden Gonzalez-Layne</li>
      <li>Mike Stan</li>
      
    </ul>
  </section>

  <section id="introduction">
    <h2>Introduction</h2>
    <p>This project uses an <strong>Arduino Uno</strong>, an <strong> IR Remote </strong>, an
      <strong> IR Receiver Module</strong>, a <strong> pushbutton </strong>, and a <strong> LED strip </strong> to turn on lights depending on what button is pressed on the ir remote and pushbutton.
  </section>

  <section id="circuit-diagram">
    <h2>Circuit Diagram</h2>
    <p>The IR receiver module recieves a signal from the IR Remote or if the pushbutton is pressed; the Arduino activates LEDs and the turns them on according to which button is pressed.</p>
    <img src="IR circuit design LED.jpg" alt="IR circuit diagram">
  </section>

  <section id="environment">
    <h2>Environmental Impact Assessment</h2>
    <ul>
      <li><strong>Materials:</strong> The Arduino Uno is RoHS and WEEE compliant, limiting hazardous substances.
      </li>
      <li><strong>Energy Efficiency:</strong> The circuit draws minimal power (~50 mA at 5V), ideal for USB or
        solar power.</li>
      <li><strong>Reusability:</strong> All components are modular and reusable, reducing electronic waste.</li>
      <li><strong>Packaging & Shipping:</strong> Ordering all components from a single supplier helps minimize
        carbon footprint.</li>
    </ul>
  </section>

  <section id="bom">
    <h2>Bill of Materials (BoM)</h2>
   <table>
  <tr>
    <th>Item</th>
    <th>Description</th>
    <th>Qty</th>
    <th>Specifications</th>
    <th>Estimated Costs (CAD)</th>
    <th>Supplier/Part Number</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>UNO R3</td>
    <td>1</td>
    <td>5V microcontroller, ATmega328P</td>
    <td>$20.00</td>
    <td>SKU A000066 Arduino UNO Rev3 â€“ Reliable ATmega328P Board with Digital & Analog I/O â€” Arduino Online Shop</td>
  </tr>
  <tr>
    <td>2</td>
    <td>IR Remote</td>
    <td>1</td>
    <td>38KHz infrared remote</td>
    <td>$2.00</td>
    <td>SKU: ACC-085 Mini IR Remote - Black - BC Robotics</td>
  </tr>
  <tr>
    <td>3</td>
    <td>IR Receiver Module</td>
    <td>1</td>
    <td>1838 infrared receiving head</td>
    <td>$1.00</td>
    <td>Generic 3Pin KY-022 TL1838 VS1838B 1838 Universal IR Infrared Sensor Receiver Module DIY Starter Kit : Amazon.ca: Electronics</td>
  </tr>
  <tr>
    <td>4</td>
    <td>USB Cable</td>
    <td>1</td>
    <td>USB-B Male to USB-A Male</td>
    <td>$15.00</td>
    <td>Generic Cmple - USB Printer Cable USB 2.0 A Male to B Male USB Cord for Printers, Scanners, External Hard Drives Camera - 3 Feet, Black : Amazon.ca: Electronics</td>
  </tr>
  <tr>
    <td>5</td>
    <td>Breadboard</td>
    <td>1</td>
    <td>830 Tie-points Breadboard</td>
    <td>$9.80</td>
    <td>LS-00019 OSEPP Electronics | Mouser Canada</td>
  </tr>
  <tr>
    <td>6</td>
    <td>Jumper Wires</td>
    <td>several</td>
    <td>Male to male, 20cm; Female to female 20cm</td>
    <td>$4.33</td>
    <td>Amazon | Male-to-Male, Female-to-Female Jumper Cables</td>
  </tr>
  <tr>
    <td>7</td>
    <td>Resistors (for LED)</td>
    <td>5</td>
    <td>220Ohms Â± 1%</td>
    <td>$0.63</td>
    <td>AliExpress 220 Ohm 100pcs</td>
  </tr>
  <tr>
    <td>8</td>
    <td>Computer (for programming)</td>
    <td>1</td>
    <td>Any with Arduino IDE installed</td>
    <td>-</td>
    <td>-</td>
  </tr>
  <tr>
    <td>9</td>
    <td>RGB LED</td>
    <td>1</td>
    <td>Forward Voltage: 3.0-3.4V, 20mA/channel, 35mm</td>
    <td>$3.25</td>
    <td>AliExpress RGB LED 100pcs</td>
  </tr>
  <tr>
    <td>10</td>
    <td>3D printed shell</td>
    <td>1</td>
    <td>A Box containing the components with an extuding panel housing the leds with an art piece on the panel</td>
    <td>-</td>
    <td>-</td>
  </tr>
  <tr>
    <td>11</td>
    <td>Blue LED</td>
    <td>1</td>
    <td>20mA, 2V Forward Voltage, 5mm</td>
    <td>$0.99</td>
    <td>Basic 5mm LED (1x Blue) in Canada Robotix</td>
  </tr>
  <tr>
    <td>12</td>
    <td>Yellow LED</td>
    <td>1</td>
    <td>20mA, 2V Forward Voltage, 5mm</td>
    <td>$0.25</td>
    <td>5mm Yellow LED - Basic - 1.8V 20mA - BC Robotics</td>
  </tr>
</table>

  </section>

  <section id="prototype">
    <h2>Prototype</h2>
    <p>The following image shows the assembled prototype on a breadboard.</p>
    <img src="prototype - 1.jpg" alt="Infrared Remote control prototype">
  </section>

  <section id="code">
    <h2>Arduino Code</h2>
    <p>The following Arduino code controls the system, lighting LEDs and activating the buzzer based on distance
      readings from the HC-SR04 sensor.</p>

    <pre class="line-numbers">
  <button class="copy-btn" onclick="copyCode()">Copy</button>
  <code id="arduinoCode" class="language-cpp">
#include <Adafruit_NeoPixel.h>
#include <IRremote.hpp>

// ===== HARDWARE SETTINGS =====
#define LED_PIN       6
#define IR_PIN        A0
#define BUTTON_PIN    3
#define NUM_LEDS      8
#define MAX_BRIGHTNESS 150

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

// ===== GAME STATE =====
bool gameModeActive = false;
bool gameRunning = false;

// LED tracking: 0=blue, 1=purple, 2=white (contested)
int ledStates[NUM_LEDS] = {0};

// Game scoring
int playerScore = 0;
int computerScore = 0;
int roundsPlayed = 0;
const int TOTAL_ROUNDS = 22;      // 22 half-second rounds â‰ˆ 11 seconds game
const int SCORE_TO_WIN = 11;      // Need 11 points to capture all LEDs

// Real hardware button (INTERRUPT DRIVEN)
volatile int buttonPressCount = 0;
unsigned long lastInterruptTime = 0;

// Round variables (0.5 seconds!)
unsigned long roundStartTime = 0;
int currentRoundTarget = 0;
bool roundActive = false;

// Frontline tracking
int frontlineIndex = -1;          // -1 means no frontline yet
int frontlineOwner = -1;          // -1=neutral, 0=player facing, 1=computer facing

// IR control
int currentPattern = 0;

// ===== INTERRUPT SERVICE ROUTINE =====
void buttonISR() {
  unsigned long currentTime = millis();
  // Real hardware: 50ms debounce for fast mashing
  if (currentTime - lastInterruptTime > 50) {
    buttonPressCount++;
    lastInterruptTime = currentTime;
  }
}

// ===== SETUP =====
void setup() {
  Serial.begin(115200); // Faster for half-second rounds
  
  // Initialize NeoPixels
  strip.begin();
  strip.setBrightness(MAX_BRIGHTNESS);
  
  // Initialize IR receiver
  IrReceiver.begin(IR_PIN, ENABLE_LED_FEEDBACK);
  
  // Initialize button with INTERRUPT
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), buttonISR, FALLING);
  
  // Initialize LED states: half blue, half purple
  for (int i = 0; i < NUM_LEDS; i++) {
    ledStates[i] = (i < NUM_LEDS/2) ? 0 : 1; // 0=blue, 1=purple
  }
  frontlineIndex = -1; // No frontline initially
  frontlineOwner = -1;
  
  updateLEDDisplay();
  
  Serial.println(F("=== DRAGON BALL Z: ADVANCED BEAM STRUGGLE ==="));
  Serial.println(F("IR: 69=Anim, 70=Blue, 71=Purple, 72=GameMode"));
  Serial.println(F("0.5-second rounds! White=contested territory"));
}

// ===== MAIN LOOP =====
void loop() {
  // Check IR remote
  if (IrReceiver.decode()) {
    handleIRCommand(IrReceiver.decodedIRData.command);
    IrReceiver.resume();
  }
  
  // Run current mode
  if (gameRunning) {
    runGame();
  } else {
    if (gameModeActive) {
      showGameModeIndicator();
    } else if (currentPattern == 0) {
      runBeamStruggleAnimation();
    }
  }
  
  delay(10);
}

// ===== IR COMMAND HANDLER =====
void handleIRCommand(unsigned long command) {
  Serial.print(F("IR: 1 - Animation, 2 - All Blue, 3 - All Purple, 4 - Play Game"));
  Serial.println(command);
  
  switch(command) {
    case 69: // Animation
      currentPattern = 0;
      gameModeActive = false;
      gameRunning = false;
      break;
    case 70: // All Blue
      currentPattern = 1;
      gameModeActive = false;
      gameRunning = false;
      patternAllBlue();
      break;
    case 71: // All Purple
      currentPattern = 2;
      gameModeActive = false;
      gameRunning = false;
      patternAllPurple();
      break;
    case 72: // Game Mode
      if (!gameRunning) {
        gameModeActive = true;
        currentPattern = 3;
        Serial.println(F("GAME MODE: Press button to start!"));
      }
      break;
  }
}

// ===== GAME MODE INDICATOR =====
void showGameModeIndicator() {
  static unsigned long lastPulse = 0;
  static bool pulseState = false;
  
  if (millis() - lastPulse > 400) {
    lastPulse = millis();
    pulseState = !pulseState;
    
    // Orange pulse for game mode
    if (pulseState) {
      for (int i = 0; i < NUM_LEDS; i++) {
        strip.setPixelColor(i, 255, 165, 0);
      }
    } else {
      strip.clear();
    }
    strip.show();
  }
}

// ===== GAME FUNCTIONS =====
void startGame() {
  gameRunning = true;
  gameModeActive = false;
  
  // Reset game state
  playerScore = 0;
  computerScore = 0;
  roundsPlayed = 0;
  
  // Reset LED states: half blue, half purple
  for (int i = 0; i < NUM_LEDS; i++) {
    ledStates[i] = (i < NUM_LEDS/2) ? 0 : 1;
  }
  frontlineIndex = -1;
  frontlineOwner = -1;
  
  updateLEDDisplay();
  
  // Start first round
  startNewRound();
  
  Serial.println(F("\n=== GAME STARTED ==="));
  Serial.println(F("0.5-second rounds! White LEDs are contested!"));
  Serial.println(F("Win twice to capture a contested LED!"));
}

void startNewRound() {
  roundActive = true;
  roundStartTime = millis();
  
  // Reset interrupt counter safely
  noInterrupts();
  buttonPressCount = 0;
  interrupts();
  
  roundsPlayed++;
  
  // HALF-SECOND TARGETS for real hardware
  if (roundsPlayed <= 8) {
    currentRoundTarget = random(4, 8);    // 4-7 clicks in 0.5s
  } else if (roundsPlayed <= 16) {
    currentRoundTarget = random(5, 9);    // 5-8 clicks
  } else {
    currentRoundTarget = random(6, 10);   // 6-9 clicks
  }
  
  Serial.print(F("\n[Round "));
  Serial.print(roundsPlayed);
  Serial.print(F("/"));
  Serial.print(TOTAL_ROUNDS);
  Serial.print(F("] Target: "));
  Serial.print(currentRoundTarget);
  Serial.print(F(" in 0.5s | Score: "));
  Serial.print(playerScore);
  Serial.print(F("-"));
  Serial.print(computerScore);
  
  if (frontlineIndex != -1) {
    Serial.print(F(" | Frontline: LED#"));
    Serial.print(frontlineIndex);
    Serial.print(F(" ("));
    Serial.print(frontlineOwner == 0 ? F("Blue-facing") : F("Purple-facing"));
    Serial.print(F(")"));
  }
  Serial.println();
}

void runGame() {
  if (!roundActive) return;
  
  unsigned long currentTime = millis();
  
  // HALF-SECOND ROUNDS!
  if (currentTime - roundStartTime >= 500) {
    endRound();
    
    // Check for game end
    if (playerScore >= SCORE_TO_WIN || computerScore >= SCORE_TO_WIN || roundsPlayed >= TOTAL_ROUNDS) {
      endGame();
    } else {
      delay(150); // Very brief pause between 0.5s rounds
      startNewRound();
    }
  }
  
  // Visual feedback during round
  updateLEDDisplay();
}

void endRound() {
  roundActive = false;
  
  // Safely read interrupt counter
  noInterrupts();
  int pressesThisRound = buttonPressCount;
  interrupts();
  
  Serial.print(F("Pressed: "));
  Serial.print(pressesThisRound);
  Serial.print(F("/"));
  Serial.print(currentRoundTarget);
  
  // Determine winner and update LED states
  bool playerWon = (pressesThisRound >= currentRoundTarget);
  
  if (playerWon) {
    playerScore++;
    Serial.println(F(" - PLAYER WINS ROUND!"));
    updateLEDStates(true); // Player won
  } else {
    computerScore++;
    Serial.println(F(" - COMPUTER WINS ROUND!"));
    updateLEDStates(false); // Computer won
  }
  
  updateLEDDisplay();
}

// ===== NEW ADVANCED LED STATE MANAGEMENT =====
void updateLEDStates(bool playerWon) {
  int winner = playerWon ? 0 : 1; // 0=blue/player, 1=purple/computer
  
  if (frontlineIndex == -1) {
    // No frontline yet - create one at the boundary
    if (playerWon) {
      // Player wins: create frontline at first purple position
      frontlineIndex = NUM_LEDS/2; // First purple LED
      frontlineOwner = 0; // Player-facing (blue wants to claim it)
      ledStates[frontlineIndex] = 2; // Make it white
    } else {
      // Computer wins: create frontline at last blue position
      frontlineIndex = NUM_LEDS/2 - 1; // Last blue LED
      frontlineOwner = 1; // Computer-facing (purple wants to claim it)
      ledStates[frontlineIndex] = 2; // Make it white
    }
  } else {
    // Frontline exists
    if (playerWon) {
      if (frontlineOwner == 0) {
        // Frontline already faces player - convert white to blue
        ledStates[frontlineIndex] = 0; // White -> Blue
        
        // Move frontline to next purple position
        int nextIndex = frontlineIndex + 1;
        if (nextIndex < NUM_LEDS && ledStates[nextIndex] == 1) {
          // There's more purple territory to contest
          frontlineIndex = nextIndex;
          ledStates[frontlineIndex] = 2; // New white frontline
          // frontlineOwner stays 0 (still player-facing)
        } else {
          // No more purple territory - reset frontline
          frontlineIndex = -1;
          frontlineOwner = -1;
        }
      } else {
        // Frontline faces computer - flip it to player-facing
        frontlineOwner = 0;
        // LED stays white but now faces player
      }
    } else {
      // Computer won
      if (frontlineOwner == 1) {
        // Frontline already faces computer - convert white to purple
        ledStates[frontlineIndex] = 1; // White -> Purple
        
        // Move frontline to next blue position
        int nextIndex = frontlineIndex - 1;
        if (nextIndex >= 0 && ledStates[nextIndex] == 0) {
          // There's more blue territory to contest
          frontlineIndex = nextIndex;
          ledStates[frontlineIndex] = 2; // New white frontline
          // frontlineOwner stays 1 (still computer-facing)
        } else {
          // No more blue territory - reset frontline
          frontlineIndex = -1;
          frontlineOwner = -1;
        }
      } else {
        // Frontline faces player - flip it to computer-facing
        frontlineOwner = 1;
        // LED stays white but now faces computer
      }
    }
  }
}

void updateLEDDisplay() {
  // First pass: set all LEDs to their base colors
  for (int i = 0; i < NUM_LEDS; i++) {
    switch(ledStates[i]) {
      case 0: // Blue
        strip.setPixelColor(i, 0, 0, 255);
        break;
      case 1: // Purple
        strip.setPixelColor(i, 255, 0, 255);
        break;
      case 2: // White (contested)
        // Make white LEDs brighter and pulse during active rounds
        if (roundActive) {
          unsigned long pulsePhase = (millis() - roundStartTime) % 200;
          int brightness = (pulsePhase < 100) ? 255 : 150;
          strip.setPixelColor(i, brightness, brightness, brightness);
        } else {
          strip.setPixelColor(i, 255, 255, 255);
        }
        break;
    }
  }
  
  // Highlight the frontline with directional indicator
  if (frontlineIndex != -1 && roundActive) {
    // Show which direction the frontline faces
    if (frontlineOwner == 0) {
      // Player-facing: add blue tint to right side
      if (frontlineIndex < NUM_LEDS - 1) {
        strip.setPixelColor(frontlineIndex + 1, 100, 100, 255);
      }
    } else {
      // Computer-facing: add purple tint to left side
      if (frontlineIndex > 0) {
        strip.setPixelColor(frontlineIndex - 1, 255, 100, 255);
      }
    }
  }
  
  // Quick progress indicator during active round
  if (roundActive) {
    noInterrupts();
    int currentPresses = buttonPressCount;
    interrupts();
    
    float progress = min(1.0, (float)currentPresses / currentRoundTarget);
    int progressLED = frontlineIndex + (frontlineOwner == 0 ? 1 : -1);
    
    if (progressLED >= 0 && progressLED < NUM_LEDS) {
      // Show progress as green intensity
      int greenValue = (int)(progress * 255);
      int currentColor = strip.getPixelColor(progressLED);
      
      // Blend green with existing color
      int r = (currentColor >> 16) & 0xFF;
      int g = greenValue;
      int b = currentColor & 0xFF;
      
      strip.setPixelColor(progressLED, r, g, b);
    }
  }
  
  strip.show();
}

void endGame() {
  gameRunning = false;
  
  Serial.println(F("\n=== GAME OVER ==="));
  Serial.print(F("Final Score: BLUE "));
  Serial.print(playerScore);
  Serial.print(F(" - "));
  Serial.print(computerScore);
  Serial.println(F(" PURPLE"));
  
  // Count territories
  int blueCount = 0, purpleCount = 0;
  for (int i = 0; i < NUM_LEDS; i++) {
    if (ledStates[i] == 0) blueCount++;
    else if (ledStates[i] == 1) purpleCount++;
  }
  
  Serial.print(F("Territory: "));
  Serial.print(blueCount);
  Serial.print(F(" blue, "));
  Serial.print(purpleCount);
  Serial.println(F(" purple"));
  
  // Determine winner
  if (blueCount > purpleCount) {
    Serial.println(F("âœ¨ BLUE WINS! KAMEHAMEHA DOMINATES! âœ¨"));
    playerVictoryAnimation();
  } else if (purpleCount > blueCount) {
    Serial.println(F("ðŸ’¥ PURPLE WINS! GALICK GUN PREVAILS! ðŸ’¥"));
    computerVictoryAnimation();
  } else {
    Serial.println(F("âš¡ DRAW! THE BEAMS CANCEL OUT! âš¡"));
    drawAnimation();
  }
  
  Serial.print(F("Total time: "));
  Serial.print(roundsPlayed * 0.5);
  Serial.println(F(" seconds"));
  
  delay(3000);
  currentPattern = 0;
}

// ===== ANIMATIONS =====
void playerVictoryAnimation() {
  // Blue conquest animation
  for (int cycle = 0; cycle < 6; cycle++) {
    for (int i = 0; i < NUM_LEDS; i++) {
      if (cycle % 2 == 0) {
        strip.setPixelColor(i, 0, 0, 255); // Solid blue
      } else {
        strip.setPixelColor(i, 100, 100, 255); // Light blue
      }
    }
    strip.show();
    delay(150);
  }
}

void computerVictoryAnimation() {
  // Purple conquest animation
  for (int cycle = 0; cycle < 6; cycle++) {
    for (int i = 0; i < NUM_LEDS; i++) {
      if (cycle % 2 == 0) {
        strip.setPixelColor(i, 255, 0, 255); // Solid purple
      } else {
        strip.setPixelColor(i, 255, 100, 255); // Light purple
      }
    }
    strip.show();
    delay(150);
  }
}

void drawAnimation() {
  // Alternating flash
  for (int cycle = 0; cycle < 10; cycle++) {
    if (cycle % 2 == 0) {
      for (int i = 0; i < NUM_LEDS/2; i++) {
        strip.setPixelColor(i, 0, 0, 255);
      }
      for (int i = NUM_LEDS/2; i < NUM_LEDS; i++) {
        strip.setPixelColor(i, 255, 0, 255);
      }
    } else {
      strip.fill(strip.Color(255, 255, 255));
    }
    strip.show();
    delay(120);
  }
}

// ===== PATTERN FUNCTIONS =====
void runBeamStruggleAnimation() {
  static unsigned long lastUpdate = 0;
  static int step = 0;
  
  if (millis() - lastUpdate > 250) { // Slightly faster animation
    lastUpdate = millis();
    strip.clear();
    
    int meetingPoint = 4 + sin(step * 0.4) * 1.8; // More movement
    
    for (int i = 0; i < meetingPoint; i++) {
      strip.setPixelColor(i, 0, 0, 200);
    }
    for (int i = NUM_LEDS - 1; i >= meetingPoint; i--) {
      strip.setPixelColor(i, 200, 0, 200);
    }
    
    // Enhanced clash effect
    strip.setPixelColor(meetingPoint, 255, 255, 255);
    if (meetingPoint > 0) strip.setPixelColor(meetingPoint-1, 150, 150, 255);
    if (meetingPoint < NUM_LEDS-1) strip.setPixelColor(meetingPoint+1, 255, 150, 255);
    
    strip.show();
    step++;
  }
}

void patternAllBlue() {
  for (int i = 0; i < NUM_LEDS; i++) {
    strip.setPixelColor(i, 0, 0, 200);
  }
  strip.show();
}

void patternAllPurple() {
  for (int i = 0; i < NUM_LEDS; i++) {
    strip.setPixelColor(i, 200, 0, 200);
  }
  strip.show();
}
    </code></pre>

    <script>
      function copyCode() {
        const code = document.getElementById('arduinoCode').innerText;
        navigator.clipboard.writeText(code).then(() => {
          alert('Code copied to clipboard!');
        });
      }
    </script>
  </section>



  <section id="conclusion">
    <h2>Conclusion</h2>
    <p>The system effectively demonstrates using infrared remote with an remote and a pushbutton to light up LEDs using Arduino. Itâ€™s affordable, educational, and
      sustainable through reusable components.</p>
  </section>

 <section id="references">
  <h2>References</h2>
  <p>
    The following external resources and example projects demonstrate related Arduino applications 
    using an Arduino Uno, an IR Remote , an IR Receiver Module, a pushbutton , and a LED strip:
  </p>

  <ul>
    <li>
      adafruit. (n.d.). 
      <em>Adafruit NeoPixel Ãœberguide.</em> 
      adafruit. 
      <a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/basic-connections" target="_blank" rel="noopener noreferrer">
        https://learn.adafruit.com/adafruit-neopixel-uberguide/basic-connections
      </a>
    </li>

    <li>
      Circuit Basics. (n.d.). 
      <em>How to Set Up an IR Remote and Receiver on an Arduino.</em> 
      Circuit Basics. 
      <a href="https://www.circuitbasics.com/arduino-ir-remote-receiver-tutorial/" target="_blank" rel="noopener noreferrer">
        https://www.circuitbasics.com/arduino-ir-remote-receiver-tutorial/
      </a>
    </li>

    <li>
      Arduino Project Hub. (n.d.). 
      <em>Decode IR Remote Control Signals of any Remote Using Arduino.</em> 
      Arduino Project Hub. 
      <a href="https://projecthub.arduino.cc/krishna_agarwal/decode-ir-remote-control-signals-of-any-remote-using-arduino-9b8e30" target="_blank" rel="noopener noreferrer">
        https://projecthub.arduino.cc/krishna_agarwal/decode-ir-remote-control-signals-of-any-remote-using-arduino-9b8e30
      </a>
    </li>

      </a>
    </li>
  </ul>
</section>



</body>

</html>
